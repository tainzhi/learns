# info
用c实现的jpeg encoder, 读取 lenna.png, 编码后输出到 lenna.jpeg

# Usage
```shell
cmake -S. -Bbuild  
# 在windows下使用MinGW构建
cmake -G "MinGW Makefiles"  
mingw32-make

# 构建成功后
./jpeg_encoder.exe
```
# jpeg编码原理
## 图像是波

波动与图像是紧密关联的。波也可以作为图像的一种表现方法，我们完全可以用上面的波形图来表示图片，效果是等价的。其实图像的本质就是各种色彩波的叠加。

波动变化剧烈的地方就是色彩变化剧烈的地方，而频率是波动变化剧烈程度的指标，单位时间内变动剧烈，就频率高；反之，色彩平缓变化，波动低，那么频率低。

## 傅里叶变换和离散余弦变换（DCT，Discrete Cosine Transform） 
傅里叶变换将时域或空域型号转成频域信号。

由于傅里叶变换设计到复数操作，实现起来很困难，所以数字图像处理技术一般采用离散余弦变换(DCT，Discrete Cosine Transform)。

DCT变换可以将图片从像素信号转换成频率信号，高频部分位于右下角，低频部分位于左上角（x分量频率从左到右是由低到高，y分量频率从上到下是由低到高）。 变换公式如下：

$$\begin{aligned}&F(u,v)=c(u)c(v)\sum_{i=0}^{N-1}\sum_{j=0}^{N-1}f(i,j)\cos\left[\frac{(i+0.5)\pi}{N}u\right]\cos\left[\frac{(j+0.5)\pi}{N}v\right]\\&c(u)=\begin{cases}\sqrt{\frac{1}{N}},&u=0\\\sqrt{\frac{2}{N}},&u\neq0\end{cases}\end{aligned}$$

- $F(u,v)$ 为DCT变换后坐标$(u,v)$的值
- $c(u)$ $c(v)$为补偿系数，可以使DCT变换矩阵为正交矩阵
- $f(i,j)$为原图像像素值

## jpeg编码原理
### 色域变换
jpeg是以YUV颜色空间进行编码的，所以需要从RGB空间转成YUV空间

$$
\begin{align}
Y &= Min(Max(0, Round(0.299 \times R + 0.587 \times G + 0.114 \times B)), 255) \\
C_B &= Min(Max(0, Round(-0.16874 \times R + 0.3313 \times G - 0.5 \times B) + 128), 255) \\
C_R &= Min(Max(0, Round(0.5 \times R - 0.41869 \times G - 0.0813 \times B) + 128), 255)
\end{align}
$$
注意：YUV的值在[0, 255]之间

### 分块
将图像分成8*8的块，不足的补0.

### DCT变换
分块后的YUV值在[0,255], 为了能使用DCT余弦变换，要把YUV值减去128

图像信息是在空间域的，分块图像要经过上面所说的DCT变换到频率域，因为人眼对高频信息不敏感，所以变换到频率域后便于去除高频频率，实际上是使用低通滤波器过滤掉高频频率信息。

DCT变换后的频率表低频部分在表的左上角，高频部分在表的右下角

### 量化
量化的过程就是去除高频频率信息的步骤，在这一步图像被有损压缩了。
对亮度Y，明度UV分别使用不同的量化表

### Zigzag扫描
量化的频率表去除了高频部分，在表的右下方有大量的0，为了便于后续使用游程编码RLC，用zigzag扫面排序一遍

### DC系数的差分脉冲调制编码
相邻的位置值相似，所以只编码这个差值信息，可以进一步降低编码数据量。
### DC系数的中间编码
数据是二进制的写入文件后需要知道这个数据的长度，这个数据的长度通过二进制移位方法可以获取
### AC系数的游程编码
游程编码 RLC（Run Length Coding）是一种比较简单的压缩算法，其基本思想是将重复且连续出现多次的字符使用（连续出现次数，字符）来描述，从而来更进一步降低数据的传输量，举例来说，一组数据"AAAABBBCCDEEEE"，由4个A、3个B、2个C、1个D、4个E组成，经过RLC可将数据压缩为4A3B2C1D4E（由14个单位转成10个单位）。简而言之，其优点在于将重复性高的数据量压缩成小单位，然而，其缺点在于─若该数据出现频率不高，可能导致压缩结果数据量比原始数据量大，例如：原始数据"ABCDE"，压缩结果为"1A1B1C1D1E"（由5个单位转成10个单位）。

但是，在JPEG编码中，RLC的含义就同其原有的意义略有不同。在JPEG编码中，假设RLC编码之后得到了一个（M,N）的数据对，其中M是两个非零AC系数之间连续的0的个数（即，行程长度），N是下一个非零的AC系数的值。采用这样的方式进行表示，是因为AC系数当中有大量的0，而采用Zigzag扫描也会使得AC系数中有很多连续的0的存在，如此一来，便非常适合于用RLC进行编码。

举个例子来解释一下，假设有以下数据：

57, 45, 0, 0, 0, 0, 23, 0, -30, -8, 0, 0, 1, 000…
经过 0 RLC 之后：

(0,57) ; (0,45) ; (4,23) ; (1,-30) ; (0,-8) ; (2,1) ; (0,0)
注意，如果 AC 系数之间连续 0 的个数超过 16，则需要用一个扩展字节 (15,0) 来表示 16 连续的 0。这是因为后面 huffman 编码的要求，每组数字前一个表示 0 的数量的必须是 4 bit，因此只能是 0~15，所以，如果有这么一组数字：

57, 十八个0, 3, 0, 0, 0, 0, 2, 三十三个0, 895, EOB
我们实际这样编码：

(0,57) ; (15,0) (2,3) ; (4,2) ; (15,0) (15,0) (1,895) , (0,0) 注意 (15,0) 表示了 16 个连续的 0。
### 霍夫曼编码
使用标准的亮度、名都dc ac表来构建huffman树，进行编码
### jpeg文件写入
写入文件头、量化表、yuv颜色空间、huffman ac/dc表、处理后的图像数据、文件结尾标识符

## 参考
[jpeg文件格式](https://www.cnblogs.com/sddai/p/5666924.html)
[learn jpeg encoder](https://github.com/xnvi/learn-jpeg-encode/blob/master/readme.md)
[音视频编解码之路](https://segmentfault.com/a/1190000040098769)
[github: jpeg demo ](https://github.com/binglingziyu/audio-video-blog-demos)
[知乎 gezilinll：jpeg编码](https://zhuanlan.zhihu.com/p/376486491)